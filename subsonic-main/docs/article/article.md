#Introduction

Subsonic is a media streaming server written in Java. Its goal is to construct a library from your sound and video files stored on a local storage and give you access to this library by allowing you to browse and play medias. 
The media files informations are stored in a database but the medias themselves remains on raw file system.

Here is overall Subsonic architecture.


The subsonic database is a simple HSQLDB instance embedded in the Subsonic web application. The main downside of this is that an embedded database is difficult to administrate. You can not access the database from a third party application and it is difficult to backup. In addition, a HsqlDB database needs to be periodically compacted or it will be less and less efficient. 
On the other hand, an embedded HsqlDB database is very quick.

Subsonic uses a special service to populate the database from the media files found on the file system. This is the scanner service. It crawls the folders and add or update (if necessary) the media files description in the database.

All media file informations are contained in a few tables called MEDIA_FILE, ALBUM, ARTIST and GENRE. The other tables are for administration purpose only (PODCAST_EPISODE is for podcasts but I won't discuss that in this article). 
If we take a look at records distribution in the database, we notice that most of datas reside in the MEDIA_FILE table. 

![](ChartGo.png)

There are very few relations between tables, thus the Subsonic database is like a mono-table database.
In addition, Subsonic uses, beside the database, a Lucene index for search purpose.
 
That's what I call a typically document oriented application. That's not surprising as a media file is actually a document. 
Thus I thought it would be an interesting experience to use an ElasticSearch ?database? in replacement of HSQLDB. And that's i'm working on. 
This article exposes strategies and techniques I used to achieve that goal. Hope you find that interesting or helpful.

#The strategy

Fortunately, as you probably noticed above, Subsonic has a DAO Layer. 
The theory is that it would be easy to move to a different data technology by rewriting the DAO layer. 
As long as the contract of the DAO layer remains unchanged, one can replace the RDBMS storage to ElasticSearch without touching the service layer and thus the rest of the application.
Hence, the main challenge is to design a good mapping and find the appropriate query methods that will allow to reproduce the behaviour of the legacy DAO layer using ElasticSearch. 

#Two main problems

So, is it so easy to rewrite the DAO layer ?
Well, in a way, yes but I had to face two main problems. 


##The id problem

Subsonic uses integers as objects ids. On the other hand, ElasticSearch generate ids for documents that are not numeric. 
I did not want to find a way to make ElasticSearch use of integer ids in place of strings; in fact I don't even try to figure out if it's possible because I think it's better keep the natural behavior.
Neither I wanted to turn Subsonic ids to string as it would have broke the Rest API contract.
Finally, I decided to have both ElasticSearch string ids and an integer id.
The ElasticSearch document id is used between the DAO layer and ElasticSearch but the integer id is used by the Subsonic service layer.

The ElasticSearch document id is generated by ElasticSearch when each document is created. But how the integer id is calculated ? 
In Subsonic, each media file in the database targets a real file or directory on the file system. And for each media file, the absolute path of the file is stored in the MEDIA_FILE table. I then create an integer id by getting the hascode of that path (according to the String.hashcode() method).
And it works. At the moment, I'm not sure it is the best solution ever but that's easy for a POC.    

##The transactional problem

This problem is the main problem I faced. 
ElasticSearch does not react as a relational database in the sense that it is not transactional. 
When you add a document to any index, that document is not immediately visible.
But, in Subsonic, the scanner service inserts media files informations in the MEDIA_FILE table and   subsequently reads these informations to do some more things like making relations. 

#Index and mapping design

As I explained before, Subsonic significant "business" data is located in few tables.
The main one is the MEDIA_FILE table. This table actually assembles 3 kind of records. 
- the media files themselves
- the directories
- the albums
Each of these records is identified by a technical unique id, but also by the file/folder path on file system.

Beside, a list of musical genres settle in the GENRE table and a list of artists in the ARTIST table.
You must have also noticed there is an ALBUM table despite the fact that album already reside in the MEDIA_FILE table. We will see later why.

Because ElasticSearch indices are a very flexible structure (remember it's a kind of No-Sql technology), I decided to have only one unique index to represent all of these tables. It seems to me it better fits the ElasticSearch philosophy. I then break the RDBMS relational logic.
A media library is a bunch of documents (the audio files) and all information about them will reside in a that index. 
We'll see later that the ElasticSearch search capabilities will help us get rid of the other tables.

Note that this index will both replace the database and the lucene index Subsonic creates for search.

In subsonic, one can declare several "media folders". A media folder is a subset of the media library starting at a specified root directory.
It is then possible to grant or not a user to certain media folders, thus this user will only be able to see media files in the media folders he has been granted to.
ElasticSearch has a very convenient feature that allow to run a same query over one or more indices. 
In my new design, each media folder will be stored into a different index so each query will be run for a special user over the indices corresponding the media folders the user is allowed to browse.


#Rewriting of the DAO layer

The DAO layer deals with both the model objects and the backend database.
In subsonic, the DAO layer is composed of a set of DAO classes and a utility class called DaoHelper. 
Each model object has it's own DAO class that reads and writes objects from and to the database.
For example, the MEDIA_FILE table is represented in the java world by the MediaFile model class and the MediaFileDao DAO class.

To turn the DAO layer to ElasticSearch, the goal is to rewrite the DAO classes without changing the model classes.
The new DAO classes will use specific ElasticSearch techniques to read and write objects (we should also say documents) from and to ElasticSearch indices.
I used a combination of the java ElasticSearch client and the query DSL based on Json.

##The DAO utility class

As subsonic implements utilities to access the database in the DaoHelper class, I created an equivalent ElasticSearchDaoHelper. 
The ElasticSearchDaoHelper class creates the indices and provide some tools to run queries against the ElasticSearch server in a unified manner.
 
When first used, the ElasticSearchDaoHelper will create explicitly exactly one index for each media folder as shown below.

```java
          String[] indexNames = indexNames();
          for (String indexName : indexNames) {
            boolean indexExists = elasticSearchClient.admin().indices().prepareExists(indexName)
                    .execute().actionGet().isExists();
            if (!indexExists) {
              elasticSearchClient.admin().indices()
                      .prepareCreate(indexName)
                      .addMapping(MEDIA_FILE_INDEX_TYPE,
                              "path", "type=string,index=not_analyzed",
                              "parentPath", "type=string,index=not_analyzed",
                              "mediaType", "type=string,index=not_analyzed",
                              "folder", "type=string,index=not_analyzed",
                              "format", "type=string,index=not_analyzed",
                              "genre", "type=string,index=not_analyzed",
                              "artist", "type=string,index=not_analyzed",
                              "albumArtist", "type=string,index=not_analyzed",
                              "albumName", "type=string,index=not_analyzed",
                              "name", "type=string,index=not_analyzed",
                              "coverArtPath", "type=string,index=not_analyzed",
                              "created", "type=date",
                              "changed", "type=date",
                              "childrenLastUpdated", "type=date",
                              "lastPlayed", "type=date",
                              "lastScanned", "type=date",
                              "starredDate", "type=date")
                      .execute().actionGet();
            }
          }

```

The `indexNames` array is actually a set of all the media folders names; thus this code  snippet will create identical indexes for each media folder.
Each field declared correspond to a property in the MediaFile model object and is typed. 
You can see that most of these fields are `not_analyzed`. That's important to be able to search records (documents) with exact value of these fields (remember that, here, ElasticSearch is used as a kind of database). 

Then, the ElasticSearchDaoHelper contains a set of utility methods to access these indices.

###Indexing media files

Media files objects are added to the ElasticSearch backend server during the Subsonic scanning process by the scanner service. Actually this consists of indexing new documents into the proper index.
This is the job of the `indexObject` method.

```java
  public void indexObject(SubsonicESDomainObject obj, String indexName) {
    try {
      // Convert the object to a json string representation.
      String mediaFileAsJson = getMapper().writeValueAsString(obj);
      IndexResponse indexResponse = getClient().prepareIndex(
              indexName,
              ElasticSearchDaoHelper.MEDIA_FILE_INDEX_TYPE)
              .setSource(mediaFileAsJson).setVersionType(VersionType.INTERNAL).get();
      }
    } catch (JsonProcessingException e) {
      throw new RuntimeException("Error trying indexing object " + e);
    }
  }

```
 
The `indexName` parameter passed to the method is the actual name of the index (and thus of the media folder) in which the document must be created.  
The `obj` parameter must mach a model object that can be stored in the index. Such objects are of class MediaFile or Album for instance.
You can notice that the object is serialized to Json using Jackson prior to be indexed (`getMapper().writeValueAsString(obj)` where getMapper refers to the `com.fasterxml.jackson.databind.ObjectMapper` class).

To achieve this, a slight modification is done on the model objects classes. 

Each model object class implements an interface called `SubsonicESDomainObject` that enhances it with the special fields `ESId` and `version` that represent the special fields _id and _version in the ElasticSearch index.

```java
public interface SubsonicESDomainObject {

  public String getESId();

  public void setESId(String ESId);

  public int getVersion();

  public void setVersion(int version);
}
```

###Updating media files

The ElasticSearchDaoHelper class also has a method that can update an object.

```java
  public void updateObject(SubsonicESDomainObject allReadyExistsMediaFile, SubsonicESDomainObject obj, String indexName) {
    // update the media file.
    try {
      String esId = allReadyExistsMediaFile.getESId();
      int version = allReadyExistsMediaFile.getVersion();
      String json = getMapper().writeValueAsString(obj);
      UpdateResponse response = getClient().prepareUpdate(
              indexName,
              ElasticSearchDaoHelper.MEDIA_FILE_INDEX_TYPE, esId)
              .setDoc(json).setVersion(version).setVersionType(VersionType.INTERNAL)
              .get();
    } catch (JsonProcessingException e) {
      throw new RuntimeException("Error trying indexing mediaFile " + e);
    }
  }
```
